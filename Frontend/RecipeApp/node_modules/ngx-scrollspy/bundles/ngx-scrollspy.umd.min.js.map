{"version":3,"file":"ngx-scrollspy.umd.min.js","sources":["../../../node_modules/rxjs/node_modules/tslib/tslib.es6.js","../../../node_modules/rxjs/src/internal/util/isFunction.ts","../../../node_modules/rxjs/src/internal/util/hostReportError.ts","../../../node_modules/rxjs/src/internal/util/isObject.ts","../../../node_modules/rxjs/src/internal/util/tryCatch.ts","../../../node_modules/rxjs/src/internal/Subscription.ts","../../../node_modules/rxjs/src/internal/Subscriber.ts","../../../node_modules/rxjs/src/internal/util/toSubscriber.ts","../../../node_modules/rxjs/src/internal/util/pipe.ts","../../../node_modules/rxjs/src/internal/Observable.ts","../../../node_modules/rxjs/src/internal/observable/empty.ts","../../../node_modules/rxjs/src/internal/util/isScheduler.ts","../../../node_modules/rxjs/src/internal/observable/fromArray.ts","../../../node_modules/rxjs/src/internal/observable/scalar.ts","../../../node_modules/rxjs/src/internal/observable/of.ts","../../../node_modules/rxjs/src/internal/observable/throwError.ts","../../../node_modules/rxjs/src/internal/operators/throttleTime.ts","~/ngx-scrollspy/src/core/service.ts","../../../node_modules/rxjs/src/internal/config.ts","../../../node_modules/rxjs/src/internal/Observer.ts","../../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../../../node_modules/rxjs/src/internal/symbol/rxSubscriber.ts","../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../../node_modules/rxjs/src/internal/SubjectSubscription.ts","../../../node_modules/rxjs/src/internal/Subject.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts","../../../node_modules/rxjs/src/internal/scheduler/Action.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueAction.ts","../../../node_modules/rxjs/src/internal/Scheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts","../../../node_modules/rxjs/src/internal/scheduler/queue.ts","../../../node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts","../../../node_modules/rxjs/src/internal/util/subscribeToArray.ts","../../../node_modules/rxjs/src/internal/Notification.ts","../../../node_modules/rxjs/src/internal/operators/observeOn.ts","../../../node_modules/rxjs/src/internal/ReplaySubject.ts","../../../node_modules/rxjs/src/internal/scheduler/async.ts","~/ngx-scrollspy/src/core/window.directive.ts","~/ngx-scrollspy/src/core/element.directive.ts","~/ngx-scrollspy/src/plugin/index.service.ts","~/ngx-scrollspy/src/module.ts","~/ngx-scrollspy/src/plugin/affix.directive.ts","~/ngx-scrollspy/src/plugin/affix.ts","~/ngx-scrollspy/src/plugin/index.directive.ts","~/ngx-scrollspy/src/plugin/index.component.ts","~/ngx-scrollspy/src/plugin/index.ts","../../../node_modules/rxjs/src/internal/operators/audit.ts","../../../node_modules/rxjs/src/internal/operators/throttle.ts","~/ngx-scrollspy/src/plugin/infinite.directive.ts","~/ngx-scrollspy/src/plugin/infinite.ts","~/ngx-scrollspy/src/plugin/parallax.directive.ts","~/ngx-scrollspy/src/plugin/parallax.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\nexport function hostReportError(err: any) {\n  setTimeout(() => { throw err; });\n}","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): For situations where Node has multiple copies of rxjs in\n          // node_modules, we cannot rely on `instanceof` checks\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```javascript\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```javascript\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```javascript\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<R>(...operations: OperatorFunction<any, any>[]): Observable<R>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * `scheduler`. It is preferrable to use this over `empty()`.\n */\nexport const EMPTY = new Observable<never>(subscriber => subscriber.complete());\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * ![](empty.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then complete\n * ```javascript\n * const result = empty().pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'\n * ```javascript\n * const interval$ = interval(1000);\n * result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throwError}\n *\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using EMPTY constant.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nexport function emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>(subscriber => scheduler.schedule(() => subscriber.complete()));\n}\n","import { SchedulerLike } from '../types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToArray } from '../util/subscribeToArray';\n\nexport function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToArray(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let i = 0;\n      sub.add(scheduler.schedule(function () {\n        if (i === input.length) {\n          subscriber.complete();\n          return;\n        }\n        subscriber.next(input[i++]);\n        if (!subscriber.closed) {\n          sub.add(this.schedule());\n        }\n      }));\n      return sub;\n    });\n  }\n}\n","import { Observable } from '../Observable';\n\nexport function scalar<T>(value: T) {\n  const result = new Observable<T>(subscriber => {\n    subscriber.next(value);\n    subscriber.complete();\n  });\n  result._isScalar = true;\n  (result as any).value = value;\n  return result;\n}\n","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { fromArray } from './fromArray';\nimport { empty } from './empty';\nimport { scalar } from './scalar';\nimport { Observable } from '../Observable';\n\n/* tslint:disable:max-line-length */\nexport function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>;\nexport function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```javascript\n * of(10, 20, 30)\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: 10'\n * // 'next: 20'\n * // 'next: 30'\n *\n * ```\n *\n * Emit the array `[1,2,3]`\n *\n * ```javascript\n * of([1,2,3])\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: [1,2,3]'\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n * @method of\n * @owner Observable\n */\n\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  let scheduler = args[args.length - 1] as SchedulerLike;\n  if (isScheduler(scheduler)) {\n    args.pop();\n  } else {\n    scheduler = undefined;\n  }\n  switch (args.length) {\n    case 0:\n      return empty(scheduler);\n    case 1:\n      return scheduler ? fromArray(args as T[], scheduler) : scalar(args[0] as T);\n    default:\n      return fromArray(args as T[], scheduler);\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits an error notification.\n *\n * <span class=\"informal\">Just emits 'error', and nothing else.\n * </span>\n *\n * ![](throw.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the error notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then emit an error\n * ```javascript\n * import { throwError, concat, of } from 'rxjs';\n *\n * const result = concat(of(7), throwError(new Error('oops!')));\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```javascript\n *\n * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13\n * ```javascript\n * import { throwError, interval, of } from 'rxjs';\n * import { mergeMap } from 'rxjs/operators';\n *\n * interval(1000).pipe(\n *   mergeMap(x => x === 13\n *     ? throwError('Thirteens are bad')\n *     : of('a', 'b', 'c')\n *   ),\n * ).subscribe(x => console.log(x), e => console.error(e));\n * ```\n * @see {@link Observable}\n * @see {@link empty}\n * @see {@link never}\n * @see {@link of}\n *\n * @param {any} error The particular Error to pass to the error notification.\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the error notification.\n * @return {Observable} An error Observable: emits only the error notification\n * using the given error argument.\n * @static true\n * @name throw\n * @owner Observable\n */\nexport function throwError(error: any, scheduler?: SchedulerLike): Observable<never> {\n  if (!scheduler) {\n    return new Observable(subscriber => subscriber.error(error));\n  } else {\n    return new Observable(subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));\n  }\n}\n\ninterface DispatchArg {\n  error: any;\n  subscriber: Subscriber<any>;\n}\n\nfunction dispatch({ error, subscriber }: DispatchArg) {\n  subscriber.error(error);\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { ThrottleConfig, defaultThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling.\n * @param {Object} config a configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport function throttleTime<T>(duration: number,\n                                scheduler: SchedulerLike = async,\n                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\n\nclass ThrottleTimeOperator<T> implements Operator<T, T> {\n  constructor(private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleTimeSubscriber<T> extends Subscriber<T> {\n  private throttled: Subscription;\n  private _hasTrailingValue: boolean = false;\n  private _trailingValue: T = null;\n\n  constructor(destination: Subscriber<T>,\n              private duration: number,\n              private scheduler: SchedulerLike,\n              private leading: boolean,\n              private trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule<DispatchArg<T>>(dispatchNext, this.duration, { subscriber: this }));\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  }\n\n  protected _complete() {\n    if (this._hasTrailingValue) {\n      this.destination.next(this._trailingValue);\n      this.destination.complete();\n    } else {\n      this.destination.complete();\n    }\n  }\n\n  clearThrottle() {\n    const throttled = this.throttled;\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: ThrottleTimeSubscriber<T>;\n}\n\nfunction dispatchNext<T>(arg: DispatchArg<T>) {\n  const { subscriber } = arg;\n  subscriber.clearThrottle();\n}\n","import { Injectable, EventEmitter } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nexport class ScrollSpyService {\npublic changes$: EventEmitter<any> = new EventEmitter();\nprivate observables: any = {};\n/**\n * @param {?} key\n * @return {?}\n */\npublic getObservable(key: string): any {\n    return this.observables[key];\n  }\n/**\n * @param {?} key\n * @param {?} observable\n * @return {?}\n */\npublic setObservable(key: string, observable: ReplaySubject<any> | Observable<any>) {\n    this.observables[key] = observable;\n    this.observables = this.observables = Object.assign({}, this.observables);\n    this.changes$.next({ index: key, change: 'set' });\n  }\n/**\n * @param {?} key\n * @return {?}\n */\npublic deleteObservable(key: string) {\n    delete this.observables[key];\n    this.observables = Object.assign({}, this.observables);\n    this.changes$.next({ index: key, change: 'delete' });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollSpyService_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyService.ctorParameters;\n/** @type {?} */\nScrollSpyService.prototype.changes$;\n/** @type {?} */\nScrollSpyService.prototype.observables;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n\n  public readonly name = 'UnsubscriptionError';\n\n  constructor(public errors: any[]) {\n    super(errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (Object as any).setPrototypeOf(this, UnsubscriptionError.prototype);\n  }\n}\n","export const rxSubscriber =\n  (typeof Symbol === 'function' && typeof Symbol.for === 'function')\n    ? Symbol.for('rxSubscriber')\n    : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport class ObjectUnsubscribedError extends Error {\n\n  public readonly name = 'ObjectUnsubscribedError';\n\n  constructor() {\n    super('object unsubscribed');\n    (Object as any).setPrototypeOf(this, ObjectUnsubscribedError.prototype);\n  }\n}\n","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class QueueAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: QueueScheduler,\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return (delay > 0 || this.closed) ?\n      super.execute(state, delay) :\n      this._execute(state, delay) ;\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Otherwise flush the scheduler starting with this action.\n    return scheduler.flush(this);\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nexport class Scheduler implements SchedulerLike {\n\n  /**\n   * Note: the extra arrow function wrapper is to make testing by overriding\n   * Date.now easier.\n   * @nocollapse\n   */\n  public static now: () => number = () => Date.now();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport class AsyncScheduler extends Scheduler {\n  public static delegate?: Scheduler;\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @deprecated internal use only\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @deprecated internal use only\n   */\n  public scheduled: any = undefined;\n\n  constructor(SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    super(SchedulerAction, () => {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    });\n  }\n\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return super.schedule(work, delay, state);\n    }\n  }\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```javascript\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```javascript\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\n\nexport const queue = new QueueScheduler(QueueAction);\n","import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  if (!subscriber.closed) {\n    subscriber.complete();\n  }\n};\n","import { PartialObserver } from './types';\nimport { Observable } from './Observable';\nimport { empty } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nexport class Notification<T> {\n  hasValue: boolean;\n\n  constructor(public kind: string, public value?: T, public error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Delivers to the given `observer` the value wrapped by this Notification.\n   * @param {Observer} observer\n   * @return\n   */\n  observe(observer: PartialObserver<T>): any {\n    switch (this.kind) {\n      case 'N':\n        return observer.next && observer.next(this.value);\n      case 'E':\n        return observer.error && observer.error(this.error);\n      case 'C':\n        return observer.complete && observer.complete();\n    }\n  }\n\n  /**\n   * Given some {@link Observer} callbacks, deliver the value represented by the\n   * current Notification to the correctly corresponding callback.\n   * @param {function(value: T): void} next An Observer `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return next && next(this.value);\n      case 'E':\n        return error && error(this.error);\n      case 'C':\n        return complete && complete();\n    }\n  }\n\n  /**\n   * Takes an Observer or its individual callback functions, and calls `observe`\n   * or `do` methods accordingly.\n   * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n   * the `next` callback.\n   * @param {function(err: any): void} [error] An Observer `error` callback.\n   * @param {function(): void} [complete] An Observer `complete` callback.\n   * @return {any}\n   */\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') {\n      return this.observe(<PartialObserver<T>>nextOrObserver);\n    } else {\n      return this.do(<(value: T) => void>nextOrObserver, error, complete);\n    }\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   * @return {any}\n   */\n  toObservable(): Observable<T> {\n    const kind = this.kind;\n    switch (kind) {\n      case 'N':\n        return of(this.value);\n      case 'E':\n        return throwError(this.error);\n      case 'C':\n        return empty();\n    }\n    throw new Error('unexpected notification kind value');\n  }\n\n  private static completeNotification: Notification<any> = new Notification('C');\n  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);\n\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createNext<T>(value: T): Notification<T> {\n    if (typeof value !== 'undefined') {\n      return new Notification('N', value);\n    }\n    return Notification.undefinedValueNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   */\n  static createError<T>(err?: any): Notification<T> {\n    return new Notification('E', undefined, err);\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   */\n  static createComplete(): Notification<any> {\n    return Notification.completeNotification;\n  }\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\n\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n * Ensure values in subscribe are called just before browser repaint.\n * ```javascript\n * const intervals = interval(10);                // Intervals are scheduled\n *                                                // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler),          // ...but we will observe on animationFrame\n * )                                              // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return function observeOnOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nexport class ObserveOnOperator<T> implements Operator<T, T> {\n  constructor(private scheduler: SchedulerLike, private delay: number = 0) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\n  /** @nocollapse */\n  static dispatch(this: SchedulerAction<ObserveOnMessage>, arg: ObserveOnMessage) {\n    const { notification, destination } = arg;\n    notification.observe(destination);\n    this.unsubscribe();\n  }\n\n  constructor(destination: Subscriber<T>,\n              private scheduler: SchedulerLike,\n              private delay: number = 0) {\n    super(destination);\n  }\n\n  private scheduleMessage(notification: Notification<any>): void {\n    this.add(this.scheduler.schedule(\n      ObserveOnSubscriber.dispatch,\n      this.delay,\n      new ObserveOnMessage(notification, this.destination)\n    ));\n  }\n\n  protected _next(value: T): void {\n    this.scheduleMessage(Notification.createNext(value));\n  }\n\n  protected _error(err: any): void {\n    this.scheduleMessage(Notification.createError(err));\n  }\n\n  protected _complete(): void {\n    this.scheduleMessage(Notification.createComplete());\n  }\n}\n\nexport class ObserveOnMessage {\n  constructor(public notification: Notification<any>,\n              public destination: PartialObserver<any>) {\n  }\n}\n","import { Subject } from './Subject';\nimport { SchedulerLike } from './types';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: (ReplayEvent<T> | T)[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n  private _infiniteTimeWindow: boolean = false;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: SchedulerLike) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      this._infiniteTimeWindow = true;\n      this.next = this.nextInfiniteTimeWindow;\n    } else {\n      this.next = this.nextTimeWindow;\n    }\n  }\n\n  private nextInfiniteTimeWindow(value: T): void {\n    const _events = this._events;\n    _events.push(value);\n    // Since this method is invoked in every next() call than the buffer\n    // can overgrow the max size only by one item\n    if (_events.length > this._bufferSize) {\n      _events.shift();\n    }\n\n    super.next(value);\n  }\n\n  private nextTimeWindow(value: T): void {\n    this._events.push(new ReplayEvent(this._getNow(), value));\n    this._trimBufferThenGetEvents();\n\n    super.next(value);\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n    const _infiniteTimeWindow = this._infiniteTimeWindow;\n    const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    const len = _events.length;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(<T>_events[i]);\n      }\n    } else {\n      for (let i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next((<ReplayEvent<T>>_events[i]).value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = <ReplayEvent<T>[]>this._events;\n\n    const eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```javascript\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```javascript\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","import { Directive, Injectable, OnInit } from '@angular/core';\nimport { ReplaySubject } from 'rxjs';\nimport { ScrollSpyService } from './service';\nexport class ScrollSpyDirective implements OnInit {\nprivate scrollStream$: ReplaySubject<any> = new ReplaySubject(1);\n/**\n * @param {?} scrollSpy\n */\nconstructor(\nprivate scrollSpy: ScrollSpyService\n  ) {}\n/**\n * @return {?}\n */\nngOnInit() {\n    if (!!this.scrollSpy.getObservable('window')) {\n      console.warn('ScrollSpy: duplicate id \"window\". Instance will be skipped!');\n    } else {\n      this.scrollSpy.setObservable('window', this.scrollStream$);\n    }\n  }\n/**\n * @param {?} $event\n * @return {?}\n */\nonScroll($event: any) {\n    this.scrollStream$.next($event);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n{ type: Directive, args: [{\n  selector: '[scrollSpy]',\n  host: {\n    '(window:scroll)': 'onScroll($event)'\n  }\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ScrollSpyService, },\n];\n}\n\nfunction ScrollSpyDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyDirective.ctorParameters;\n/** @type {?} */\nScrollSpyDirective.prototype.scrollStream$;\n/** @type {?} */\nScrollSpyDirective.prototype.scrollSpy;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Directive, Injectable, Input, OnInit, OnDestroy } from '@angular/core';\nimport { ReplaySubject } from 'rxjs';\nimport { ScrollSpyService } from './service';\nexport class ScrollSpyElementDirective implements OnInit, OnDestroy {\npublic scrollSpyId: string;\nprivate scrollStream$: ReplaySubject<any> = new ReplaySubject(1);\n/**\n * @param {?} scrollSpy\n */\nconstructor(\nprivate scrollSpy: ScrollSpyService\n  ) {}\n/**\n * @return {?}\n */\nngOnInit() {\n    if (!this.scrollSpyId) {\n      return console.warn('ScrollSpy: Missing id.');\n    }\n\n    if (!!this.scrollSpy.getObservable(this.scrollSpyId)) {\n      console.warn('ScrollSpy: duplicate id \"' + this.scrollSpyId + '\". Instance will be skipped!');\n    } else {\n      this.scrollSpy.setObservable(this.scrollSpyId, this.scrollStream$);\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.scrollSpy.deleteObservable(this.scrollSpyId);\n  }\n/**\n * @param {?} $event\n * @return {?}\n */\nonScroll($event: any) {\n    this.scrollStream$.next($event);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n{ type: Directive, args: [{\n  selector: '[scrollSpyElement]',\n  host: {\n    '(scroll)': 'onScroll($event)'\n  }\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ScrollSpyService, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'scrollSpyId': [{ type: Input, args: ['scrollSpyElement', ] },],\n};\n}\n\nfunction ScrollSpyElementDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyElementDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyElementDirective.ctorParameters;\n/** @type {?} */\nScrollSpyElementDirective.propDecorators;\n/** @type {?} */\nScrollSpyElementDirective.prototype.scrollSpyId;\n/** @type {?} */\nScrollSpyElementDirective.prototype.scrollStream$;\n/** @type {?} */\nScrollSpyElementDirective.prototype.scrollSpy;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable, EventEmitter } from '@angular/core';\nexport class ScrollSpyIndexService {\npublic changes$: EventEmitter<any> = new EventEmitter();\nprivate indexes: any = {};\n/**\n * @param {?} key\n * @return {?}\n */\npublic getIndex(key: string): any {\n    return this.indexes[key];\n  }\n/**\n * @param {?} key\n * @param {?} index\n * @return {?}\n */\npublic setIndex(key: string, index: any) {\n    this.indexes[key] = index;\n    this.indexes = this.indexes = Object.assign({}, this.indexes);\n    this.changes$.emit({ index: key, change: 'set' });\n  }\n/**\n * @param {?} key\n * @return {?}\n */\npublic deleteIndex(key: string) {\n    delete this.indexes[key];\n    this.indexes = Object.assign({}, this.indexes);\n    this.changes$.emit({ index: key, change: 'delete' });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollSpyIndexService_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyIndexService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyIndexService.ctorParameters;\n/** @type {?} */\nScrollSpyIndexService.prototype.changes$;\n/** @type {?} */\nScrollSpyIndexService.prototype.indexes;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\n\nimport { ScrollSpyService } from './core/service';\nimport { ScrollSpyDirective } from './core/window.directive';\nimport { ScrollSpyElementDirective } from './core/element.directive';\n\nimport { ScrollSpyIndexService } from './plugin/index.service';\nexport class ScrollSpyModule {\nconstructor() {}\n/**\n * @return {?}\n */\nstatic forRoot(): ModuleWithProviders {\n    return {\n      ngModule: ScrollSpyModule,\n      providers: [\n        ScrollSpyService,\n        ScrollSpyIndexService\n      ]\n    };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [ ScrollSpyDirective, ScrollSpyElementDirective ],\n  exports: [ ScrollSpyDirective, ScrollSpyElementDirective ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollSpyModule_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  Directive,\n  Injectable,\n  ElementRef,\n  Input,\n  AfterViewInit,\n  OnDestroy,\n  ChangeDetectorRef\n} from '@angular/core';\n\nimport { ScrollSpyService } from '../core/service';\n\nexport interface ScrollSpyAffixOptions {\n  topMargin?: number;\n  bottomMargin?: number;\n}\nexport class ScrollSpyAffixDirective implements AfterViewInit, OnDestroy {\npublic options: ScrollSpyAffixOptions;\npublic elementTop: number;\npublic elementBottom: number;\npublic affix: boolean = false;\npublic affixTop: boolean = false;\npublic affixBottom: boolean = false;\npublic defaultOptions: ScrollSpyAffixOptions = {\n    topMargin: 0,\n    bottomMargin: 0\n  };\npublic scrollStream$: any;\npublic el: HTMLElement;\npublic parentEl: any;\n/**\n * @param {?} ref\n * @param {?} elRef\n * @param {?} scrollSpy\n */\nconstructor(\nprivate ref: ChangeDetectorRef,\nprivate elRef: ElementRef,\nprivate scrollSpy: ScrollSpyService\n  ) {\n    this.el = elRef.nativeElement;\n  }\n/**\n * @return {?}\n */\nngAfterViewInit() {\n    if (!this.options) {\n      this.options = {};\n    }\n\n    this.options = Object.assign(this.defaultOptions, this.options);\n\n    this.parentEl = this.el.parentElement;\n    this.elementTop = this.parentEl.scrollTop;\n    this.elementBottom = this.elementTop + this.parentEl.getBoundingClientRect().height;\n\n    if (!!this.scrollSpy.getObservable('window')) {\n      // TODO: Remove setTimeout once: https://github.com/angular/angular/issues/7443\n      this.scrollStream$ = this.scrollSpy.getObservable('window').subscribe((e: any) => {\n        if (typeof e.target.scrollingElement !== 'undefined') {\n          setTimeout(() => this.update(e.target.scrollingElement.scrollTop));\n        } else if (typeof e.target.scrollY !== 'undefined') {\n          setTimeout(() => this.update(e.target.scrollY));\n        } else if (typeof e.target.pageYOffset !== 'undefined') {\n          setTimeout(() => this.update(e.target.pageYOffset));\n        } else if(e.target.parentWindow && e.target.parentWindow.pageYOffset) {\n          setTimeout(() => this.update(e.target.parentWindow.pageYOffset));\n        }\n      });\n    }\n  }\n/**\n * @param {?} currentTop\n * @return {?}\n */\nupdate(currentTop: number) {\n    if (currentTop >= this.elementTop + this.options.topMargin) {\n      if (currentTop > this.elementBottom - this.options.bottomMargin - this.el.getBoundingClientRect().height) {\n        if (this.affixTop || !this.affixBottom) {\n          this.ref.markForCheck();\n        }\n        this.affixTop = false;\n        this.affixBottom = true;\n        this.affix = true;\n      } else {\n        if (!this.affixTop || this.affixBottom) {\n          this.ref.markForCheck();\n        }\n        this.affixTop = true;\n        this.affixBottom = false;\n        this.affix = true;\n      }\n    } else {\n      if (this.affixTop) {\n        this.ref.markForCheck();\n      }\n      this.affixTop = false;\n      this.affixBottom = false;\n      this.affix = false;\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.scrollStream$.unsubscribe();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n{ type: Directive, args: [{\n  selector: '[scrollSpyAffix]',\n  host: {\n    '[class.affix]': 'affix',\n    '[class.affix-top]': 'affixTop',\n    '[class.affix-bottom]': 'affixBottom'\n  }\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ChangeDetectorRef, },\n{type: ElementRef, },\n{type: ScrollSpyService, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input, args: ['scrollSpyAffix', ] },],\n};\n}\n\nfunction ScrollSpyAffixDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyAffixDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyAffixDirective.ctorParameters;\n/** @type {?} */\nScrollSpyAffixDirective.propDecorators;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.options;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.elementTop;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.elementBottom;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.affix;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.affixTop;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.affixBottom;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.defaultOptions;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.scrollStream$;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.el;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.parentEl;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.ref;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.elRef;\n/** @type {?} */\nScrollSpyAffixDirective.prototype.scrollSpy;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\n\nexport {ScrollSpyAffixOptions,ScrollSpyAffixDirective} from './affix.directive';\n\nimport { ScrollSpyAffixDirective } from './affix.directive';\nexport class ScrollSpyAffixModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [ ScrollSpyAffixDirective ],\n  exports: [ ScrollSpyAffixDirective ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollSpyAffixModule_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyAffixModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyAffixModule.ctorParameters;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  Directive,\n  Injectable,\n  ElementRef,\n  Input,\n  OnInit,\n  AfterViewInit,\n  OnDestroy\n} from '@angular/core';\n\nimport { ScrollSpyIndexService } from './index.service';\n\nexport interface ScrollSpyIndexOptions {\n  id?: string;\n  selector?: string;\n}\nexport class ScrollSpyIndexDirective implements OnInit, AfterViewInit, OnDestroy {\npublic options: ScrollSpyIndexOptions;\npublic defaultOptions: ScrollSpyIndexOptions = {\n    selector: 'anchor'\n  };\npublic el: HTMLElement;\n/**\n * @param {?} elRef\n * @param {?} scrollSpyIndex\n */\nconstructor(\nprivate elRef: ElementRef,\nprivate scrollSpyIndex: ScrollSpyIndexService\n  ) {\n    this.el = elRef.nativeElement;\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    if (!this.options) {\n      this.options = {};\n    }\n\n    if (!this.options.id) {\n      return console.warn('ScrollSpyIndex: Missing id.');\n    }\n\n    this.options = Object.assign(this.defaultOptions, this.options);\n  }\n/**\n * @return {?}\n */\nngAfterViewInit() {\n    this.scrollSpyIndex.setIndex(this.options.id, this.el.getElementsByClassName(this.options.selector));\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.scrollSpyIndex.deleteIndex(this.options.id);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n{ type: Directive, args: [{\n  selector: '[scrollSpyIndex]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: ScrollSpyIndexService, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input, args: ['scrollSpyIndex', ] },],\n};\n}\n\nfunction ScrollSpyIndexDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyIndexDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyIndexDirective.ctorParameters;\n/** @type {?} */\nScrollSpyIndexDirective.propDecorators;\n/** @type {?} */\nScrollSpyIndexDirective.prototype.options;\n/** @type {?} */\nScrollSpyIndexDirective.prototype.defaultOptions;\n/** @type {?} */\nScrollSpyIndexDirective.prototype.el;\n/** @type {?} */\nScrollSpyIndexDirective.prototype.elRef;\n/** @type {?} */\nScrollSpyIndexDirective.prototype.scrollSpyIndex;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  Component,\n  ChangeDetectorRef,\n  Injectable,\n  Input,\n  ElementRef,\n  OnInit,\n  AfterViewInit,\n  OnDestroy,\n  ChangeDetectionStrategy\n} from '@angular/core';\n\nimport { ScrollSpyService } from '../core/service';\nimport { ScrollSpyIndexService } from './index.service';\n\nexport interface ScrollSpyIndexComponentOptions {\n  id?: string;\n  spyId?: string;\n  topMargin?: number;\n}\nexport class ScrollSpyIndexRenderComponent implements OnInit, AfterViewInit, OnDestroy {\npublic scrollSpyIndexRenderOptions: ScrollSpyIndexComponentOptions;\npublic currentScrollPosition: number;\npublic items: any[] = [];\npublic itemsHash: any = {};\npublic itemsToHighlight: Array<string> = [];\npublic defaultOptions: ScrollSpyIndexComponentOptions = {\n    spyId: 'window',\n    topMargin: 0\n  };\npublic changeStream$: any;\npublic scrollStream$: any;\npublic el: HTMLElement;\n/**\n * @param {?} ref\n * @param {?} elRef\n * @param {?} scrollSpy\n * @param {?} scrollSpyIndex\n */\nconstructor(\nprivate ref: ChangeDetectorRef,\nprivate elRef: ElementRef,\nprivate scrollSpy: ScrollSpyService,\nprivate scrollSpyIndex: ScrollSpyIndexService\n  ) {\n    this.el = elRef.nativeElement;\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    if (!this.scrollSpyIndexRenderOptions) {\n      this.scrollSpyIndexRenderOptions = {};\n    }\n\n    if (!this.scrollSpyIndexRenderOptions.id) {\n      return console.warn('ScrollSpyIndex: Missing id.');\n    }\n\n    this.scrollSpyIndexRenderOptions = Object.assign(this.defaultOptions, this.scrollSpyIndexRenderOptions);\n\n    this.changeStream$ = this.scrollSpyIndex.changes$.subscribe((e: any) => {\n      if (e.index === this.scrollSpyIndexRenderOptions.id) {\n        if (e.change === 'delete') {\n          this.update();\n        } else if (e.change === 'set') {\n          this.update();\n        }\n      }\n    });\n  }\n/**\n * @return {?}\n */\nngAfterViewInit() {\n    if (!!this.scrollSpy.getObservable(this.scrollSpyIndexRenderOptions.spyId)) {\n      this.scrollStream$ = this.scrollSpy.getObservable(this.scrollSpyIndexRenderOptions.spyId).subscribe((e: any) => {\n        if (typeof e.target.scrollingElement !== 'undefined') {\n          this.currentScrollPosition = e.target.scrollingElement.scrollTop;\n        } else if (typeof e.target.scrollY !== 'undefined') {\n          this.currentScrollPosition = e.target.scrollY;\n        } else if (typeof e.target.pageYOffset !== 'undefined') {\n          this.currentScrollPosition = e.target.pageYOffset;\n        }\n        this.calculateHighlight();\n      });\n    } else {\n      return console.warn('ScrollSpyIndexComponent: No ScrollSpy observable for id \"' + this.scrollSpyIndexRenderOptions.spyId + '\"');\n    }\n  }\n/**\n * @return {?}\n */\nupdate() {\n    const /** @type {?} */ data: Array<any> = this.scrollSpyIndex.getIndex(this.scrollSpyIndexRenderOptions.id) || [];\n\n    let /** @type {?} */ stack: Array<any> = [];\n    let /** @type {?} */ parentStack: Array<any> = [];\n    let /** @type {?} */ lastItem: any;\n\n    this.items = [];\n    this.itemsHash = {};\n\n    for (var /** @type {?} */ i = 0; i < data.length; ++i) {\n      // parse basic info from the dom item\n      var /** @type {?} */ item: any = {\n        link: data[i].id,\n        text: data[i].textContent || data[i].innerText,\n        parents: [],\n        children: []\n      };\n\n      // build type identifier\n      var /** @type {?} */ level: string = data[i].tagName;\n      for (var /** @type {?} */ n = 0; n < data[i].classList.length; n++) {\n        level += ',' + data[i].classList[n];\n      }\n\n      // here be dragons\n      var /** @type {?} */ stacksize: number = stack.length;\n      if (stacksize === 0) {\n        // we are at the top level and will stay there\n        stack.push(level);\n      } else if (level !== stack[stacksize - 1]) {\n        // traverse the ancestry, looking for a match\n        for (var /** @type {?} */ j = stacksize - 1; j >= 0; j--) {\n          if (level === stack[j]) {\n            break; // found an ancestor\n          }\n        }\n        if (j < 0) {\n          // this is a new submenu item, lets push the stack\n          stack.push(level);\n          parentStack.push(lastItem);\n        } else {\n          // we are either a sibling or higher up the tree,\n          // lets pop the stack if needed\n          while (stack.length > j + 1) {\n            stack.pop();\n            parentStack.pop();\n          }\n        }\n      }\n\n      // for next iteration\n      lastItem = item.link;\n\n      // if we have a parent, lets record it\n      if (parentStack.length > 0) {\n        item.parents = [...parentStack];\n\n        let /** @type {?} */ temp: any = this.items;\n        for (var /** @type {?} */ t = 0; t < parentStack.length; ++t) {\n          if (t < parentStack.length - 1) {\n            temp = temp.filter((e: any) => { return e.link === parentStack[t]; })[0].children;\n          } else {\n            temp.filter((e: any) => { return e.link === parentStack[t]; })[0].children.push(item);\n          }\n        }\n      } else {\n        this.items.push(item);\n      }\n\n      this.itemsHash[item.link] = item;\n    }\n\n    setTimeout(() => {\n      this.calculateHighlight();\n    });\n  }\n/**\n * @return {?}\n */\ncalculateHighlight() {\n    var /** @type {?} */ items: Array<any> = this.scrollSpyIndex.getIndex(this.scrollSpyIndexRenderOptions.id);\n    this.itemsToHighlight = [];\n\n    if (!items || !items.length) {\n      return;\n    }\n\n    var /** @type {?} */ highlightItem: string;\n    for (var /** @type {?} */ i = items.length - 1; i >= 0; i--) {\n      if (this.currentScrollPosition - (items[i].offsetTop + this.scrollSpyIndexRenderOptions.topMargin) >= 0) {\n        highlightItem = items[i].id;\n        break;\n      }\n    }\n\n    if (!highlightItem) {\n      highlightItem = items[0].id;\n    }\n    this.itemsToHighlight = [highlightItem, ...this.itemsHash[highlightItem].parents];\n\n    this.ref.markForCheck();\n  }\n/**\n * @param {?} id\n * @return {?}\n */\nhighlight(id: string): boolean {\n    return this.itemsToHighlight.indexOf(id) !== -1;\n  }\n/**\n * @param {?} anchor\n * @return {?}\n */\ngoTo(anchor: string) {\n    setTimeout(() => {\n      document.querySelector('#' + anchor).scrollIntoView();\n    });\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.changeStream$.unsubscribe();\n    this.scrollStream$.unsubscribe();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n{ type: Component, args: [{\n  selector: 'scrollSpy-index-render',\n  template: `\n  <div #container>\n    <ul class=\"nav flex-column menu\">\n      <li *ngFor=\"let item of items\" [class.active]=\"highlight(item.link)\">\n        <a [routerLink]=\"\" fragment=\"{{item.link}}\" (click)=\"goTo(item.link)\">{{item.text}}</a>\n        <ul *ngIf=\"item.children.length\" class=\"nav menu\">\n          <li *ngFor=\"let itemChild of item.children\" [class.active]=\"highlight(itemChild.link)\">\n            <a [routerLink]=\"\" fragment=\"{{itemChild.link}}\" (click)=\"goTo(itemChild.link)\">{{itemChild.text}}</a>\n            <ul *ngIf=\"itemChild.children.length\" class=\"nav menu\">\n              <li *ngFor=\"let itemChild1 of itemChild.children\" [class.active]=\"highlight(itemChild1.link)\">\n                <a [routerLink]=\"\" fragment=\"{{itemChild1.link}}\" (click)=\"goTo(itemChild1.link)\">{{itemChild1.text}}</a>\n                 <ul *ngIf=\"itemChild1.children.length\" class=\"nav menu\">\n                  <li *ngFor=\"let itemChild2 of itemChild1.children\" [class.active]=\"highlight(itemChild2.link)\">\n                    <a [routerLink]=\"\" fragment=\"{{itemChild2.link}}\" (click)=\"goTo(itemChild2.link)\">{{itemChild2.text}}</a>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ChangeDetectorRef, },\n{type: ElementRef, },\n{type: ScrollSpyService, },\n{type: ScrollSpyIndexService, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'scrollSpyIndexRenderOptions': [{ type: Input },],\n};\n}\n\nfunction ScrollSpyIndexRenderComponent_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyIndexRenderComponent.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyIndexRenderComponent.ctorParameters;\n/** @type {?} */\nScrollSpyIndexRenderComponent.propDecorators;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.scrollSpyIndexRenderOptions;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.currentScrollPosition;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.items;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.itemsHash;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.itemsToHighlight;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.defaultOptions;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.changeStream$;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.scrollStream$;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.el;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.ref;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.elRef;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.scrollSpy;\n/** @type {?} */\nScrollSpyIndexRenderComponent.prototype.scrollSpyIndex;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\n\nexport {ScrollSpyIndexService} from './index.service';\nexport {ScrollSpyIndexOptions,ScrollSpyIndexDirective} from './index.directive';\nexport {ScrollSpyIndexComponentOptions,ScrollSpyIndexRenderComponent} from './index.component';\n\nimport { ScrollSpyIndexDirective } from './index.directive';\nimport { ScrollSpyIndexRenderComponent } from './index.component';\nexport class ScrollSpyIndexModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [ CommonModule, RouterModule ],\n  declarations: [ ScrollSpyIndexDirective, ScrollSpyIndexRenderComponent ],\n  exports: [ ScrollSpyIndexDirective, ScrollSpyIndexRenderComponent ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollSpyIndexModule_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyIndexModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyIndexModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\n\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.png)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nexport function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\n  return function auditOperatorFunction(source: Observable<T>) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nclass AuditOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new AuditSubscriber<T, T>(subscriber, this.durationSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass AuditSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private value: T;\n  private hasValue: boolean = false;\n  private throttled: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this.value = value;\n    this.hasValue = true;\n    if (!this.throttled) {\n      const duration = tryCatch(this.durationSelector)(value);\n      if (duration === errorObject) {\n        this.destination.error(errorObject.e);\n      } else {\n        const innerSubscription = subscribeToResult(this, duration);\n        if (!innerSubscription || innerSubscription.closed) {\n          this.clearThrottle();\n        } else {\n          this.add(this.throttled = innerSubscription);\n        }\n      }\n    }\n  }\n\n  clearThrottle() {\n    const { value, hasValue, throttled } = this;\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = null;\n      throttled.unsubscribe();\n    }\n    if (hasValue) {\n      this.value = null;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R, outerIndex: number, innerIndex: number): void {\n    this.clearThrottle();\n  }\n\n  notifyComplete(): void {\n    this.clearThrottle();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\n\nexport interface ThrottleConfig {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport const defaultThrottleConfig: ThrottleConfig = {\n  leading: true,\n  trailing: false\n};\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.png)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value or completes, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n * Emit clicks at a rate of at most one click per second\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration for each source value, returned as an Observable or a Promise.\n * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n * to `{ leading: true, trailing: false }`.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttle\n * @owner Observable\n */\nexport function throttle<T>(durationSelector: (value: T) => SubscribableOrPromise<any>,\n                            config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));\n}\n\nclass ThrottleOperator<T> implements Operator<T, T> {\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private _throttled: Subscription;\n  private _sendValue: T;\n  private _hasValue = false;\n\n  constructor(protected destination: Subscriber<T>,\n              private durationSelector: (value: T) => SubscribableOrPromise<number>,\n              private _leading: boolean,\n              private _trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    this._hasValue = true;\n    this._sendValue = value;\n\n    if (!this._throttled) {\n      if (this._leading) {\n        this.send();\n      } else {\n        this.throttle(value);\n      }\n    }\n  }\n\n  private send() {\n    const { _hasValue, _sendValue } = this;\n    if (_hasValue) {\n      this.destination.next(_sendValue);\n      this.throttle(_sendValue);\n    }\n    this._hasValue = false;\n    this._sendValue = null;\n  }\n\n  private throttle(value: T): void {\n    const duration = this.tryDurationSelector(value);\n    if (duration) {\n      this.add(this._throttled = subscribeToResult(this, duration));\n    }\n  }\n\n  private tryDurationSelector(value: T): SubscribableOrPromise<any> {\n    try {\n      return this.durationSelector(value);\n    } catch (err) {\n      this.destination.error(err);\n      return null;\n    }\n  }\n\n  private throttlingDone() {\n    const { _throttled, _trailing } = this;\n    if (_throttled) {\n      _throttled.unsubscribe();\n    }\n    this._throttled = null;\n\n    if (_trailing) {\n      this.send();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.throttlingDone();\n  }\n\n  notifyComplete(): void {\n    this.throttlingDone();\n  }\n}\n","import {\n  Directive,\n  Injectable,\n  Input,\n  Output,\n  EventEmitter,\n  OnInit,\n  AfterViewInit,\n  OnDestroy\n} from '@angular/core';\nimport { throttleTime } from 'rxjs/operators';\n\nimport { ScrollSpyService } from '../core/service';\n\nexport interface ScrollSpyInfiniteOptions {\n  spyId?: string;\n  distanceRatio?: number;\n}\nexport class ScrollSpyInfiniteDirective implements OnInit, AfterViewInit, OnDestroy {\npublic options: ScrollSpyInfiniteOptions;\npublic scrollSpyInfiniteDisabled: boolean;\npublic scrollSpyInfiniteEvent: EventEmitter<any> = new EventEmitter();\npublic defaultOptions: ScrollSpyInfiniteOptions = {\n    spyId: 'window',\n    distanceRatio: 1\n  };\npublic scrollStream$: any;\n/**\n * @param {?} scrollSpy\n */\nconstructor(\nprivate scrollSpy: ScrollSpyService\n  ) {}\n/**\n * @return {?}\n */\nngOnInit() {\n    if (!this.options) {\n      this.options = {};\n    }\n\n    this.options = Object.assign(this.defaultOptions, this.options);\n\n    if (this.scrollSpyInfiniteDisabled === undefined) {\n      this.scrollSpyInfiniteDisabled = false;\n    }\n  }\n/**\n * @return {?}\n */\nngAfterViewInit() {\n    if (!!this.scrollSpy.getObservable(this.options.spyId)) {\n      this.scrollStream$ = this.scrollSpy.getObservable(this.options.spyId).pipe(throttleTime(200)).subscribe((e: any) => {\n        if (!this.scrollSpyInfiniteDisabled) {\n          this.evaluateScroll(e.target);\n        }\n      });\n    } else {\n      return console.warn('ScrollSpyInfinite: No ScrollSpy observable for id \"' + this.options.spyId + '\"');\n    }\n  }\n/**\n * @param {?} target\n * @return {?}\n */\nevaluateScroll(target: any) {\n    if (this.options.spyId === 'window') {\n      const /** @type {?} */ scrollHeight = target.document.documentElement.scrollHeight;\n      const /** @type {?} */ scrollTop = target.pageYOffset || target.parentWindow.pageYOffset;\n      const /** @type {?} */ offsetHeight = target.document.documentElement.clientHeight;\n\n      if (scrollHeight - scrollTop - offsetHeight <= offsetHeight * this.options.distanceRatio) {\n        this.scrollSpyInfiniteEvent.next({});\n      }\n    } else {\n      const /** @type {?} */ scrollHeight = target.scrollingElement ?\n        target.scrollingElement.scrollHeight\n        : target.scrollHeight;\n\n      const /** @type {?} */ scrollTop = target.scrollingElement ?\n        target.scrollingElement.scrollTop\n        : target.scrollTop;\n\n      const /** @type {?} */ offsetHeight = target.scrollingElement ?\n        target.scrollingElement.offsetHeight\n        : target.offsetHeight;\n\n      if (scrollHeight - scrollTop - offsetHeight <= offsetHeight * this.options.distanceRatio) {\n        this.scrollSpyInfiniteEvent.next({});\n      }\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.scrollStream$.unsubscribe();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n{ type: Directive, args: [{\n  selector: '[scrollSpyInfinite]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ScrollSpyService, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input, args: ['scrollSpyInfinite', ] },],\n'scrollSpyInfiniteDisabled': [{ type: Input },],\n'scrollSpyInfiniteEvent': [{ type: Output },],\n};\n}\n\nfunction ScrollSpyInfiniteDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyInfiniteDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyInfiniteDirective.ctorParameters;\n/** @type {?} */\nScrollSpyInfiniteDirective.propDecorators;\n/** @type {?} */\nScrollSpyInfiniteDirective.prototype.options;\n/** @type {?} */\nScrollSpyInfiniteDirective.prototype.scrollSpyInfiniteDisabled;\n/** @type {?} */\nScrollSpyInfiniteDirective.prototype.scrollSpyInfiniteEvent;\n/** @type {?} */\nScrollSpyInfiniteDirective.prototype.defaultOptions;\n/** @type {?} */\nScrollSpyInfiniteDirective.prototype.scrollStream$;\n/** @type {?} */\nScrollSpyInfiniteDirective.prototype.scrollSpy;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\n\nexport {ScrollSpyInfiniteOptions,ScrollSpyInfiniteDirective} from './infinite.directive';\n\nimport { ScrollSpyInfiniteDirective } from './infinite.directive';\nexport class  ScrollSpyInfiniteModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [ ScrollSpyInfiniteDirective ],\n  exports: [ ScrollSpyInfiniteDirective ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollSpyInfiniteModule_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyInfiniteModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyInfiniteModule.ctorParameters;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  Directive,\n  Injectable,\n  Input,\n  ElementRef,\n  Renderer2,\n  OnInit,\n  AfterViewInit,\n  OnDestroy\n} from '@angular/core';\n\nimport { ScrollSpyService } from '../core/service';\n\nexport interface ScrollSpyParallaxOptions {\n  // (default: 'window')\n  spyId?: string;\n\n  // (default: false)\n  horizontal?: boolean;\n\n  // the css property (converted to camelCase) that you want changed along with the\n  // value you want to assign to the css key; you should use ParallaxCss if you're\n  // just defining one property without special values\n  cssKey?: string;\n\n  // this is used to define the css property you'd like to modify as you scroll\n  // default is backgroundPositionY\n  property?: string;\n\n  // ratio defining how fast, slow, or the direction of the changes on scrolling\n  ratio?: number;\n\n  // this is the initial value in pixels for the parallaxCss property you defined\n  // before or, if you didn't define one, it defaults to 0\n  initValue?: number;\n\n  // the upper constraint for the css transformation\n  max?: number;\n\n  // the lower constraint for the css transformation\n  min?: number;\n\n  // the unit (e.g. 'px', 'em', '%', 'vh', etc.)\n  unit?: string;\n\n  axis?: string;\n}\nexport class ScrollSpyParallaxDirective implements OnInit, AfterViewInit, OnDestroy {\npublic options: ScrollSpyParallaxOptions;\npublic scrollSpyParallaxDisabled: boolean;\npublic cssValue: string;\npublic isSpecialVal: boolean = false;\npublic defaultOptions: ScrollSpyParallaxOptions = {\n    spyId: 'window',\n    horizontal: false,\n    cssKey: 'backgroundPosition',\n    property: 'backgroundPositionY',\n    ratio: -.7,\n    initValue: 0,\n    unit: 'px',\n    axis: 'Y'\n  };\npublic scrollStream$: any;\npublic el: HTMLElement;\n/**\n * @param {?} renderer\n * @param {?} elRef\n * @param {?} scrollSpy\n */\nconstructor(\nprivate renderer: Renderer2,\nprivate elRef: ElementRef,\nprivate scrollSpy: ScrollSpyService\n  ) {\n    this.el = elRef.nativeElement;\n  }\n/**\n * @return {?}\n */\nngOnInit() {\n    if (!this.options) {\n      this.options = {};\n    }\n\n    this.options = Object.assign(this.defaultOptions, this.options);\n\n    if (this.scrollSpyParallaxDisabled === undefined) {\n      this.scrollSpyParallaxDisabled = false;\n    }\n\n    if (this.options.property.match(/backgroundPosition/i)) {\n      if (this.options.property.split('backgroundPosition')[1].toUpperCase() === 'X') {\n        this.options.axis = 'X';\n      }\n\n      this.options.property = 'backgroundPosition';\n    }\n\n    let /** @type {?} */ cssValArray: Array<string>;\n\n    cssValArray = this.options.property.split(':');\n    this.options.cssKey = cssValArray[0];\n    this.cssValue = cssValArray[1];\n\n    this.isSpecialVal = this.cssValue ? true : false;\n\n    if (!this.cssValue) {\n      this.cssValue = this.options.cssKey;\n    }\n\n    this.options.ratio = +this.options.ratio;\n    this.options.initValue = +this.options.initValue;\n\n  }\n/**\n * @return {?}\n */\nngAfterViewInit() {\n    if (!!this.scrollSpy.getObservable(this.options.spyId)) {\n      this.scrollStream$ = this.scrollSpy.getObservable(this.options.spyId).subscribe((e: any) => {\n        if (!this.scrollSpyParallaxDisabled) {\n          this.evaluateScroll(e.target);\n        }\n      });\n    } else {\n      return console.warn('ScrollSpyParallax: No ScrollSpy observable for id \"' + this.options.spyId + '\"');\n    }\n  }\n/**\n * @param {?} target\n * @return {?}\n */\nevaluateScroll(target: any) {\n    let /** @type {?} */ currentScrollPosition: number;\n    if (typeof target.scrollTop !== 'undefined') {\n      currentScrollPosition = target.scrollTop;\n    } else if (typeof target.scrollingElement !== 'undefined') {\n      currentScrollPosition = target.scrollingElement.scrollTop;\n    } else if (typeof target.scrollY !== 'undefined') {\n      currentScrollPosition = target.scrollY;\n    } else if (typeof target.pageYOffset !== 'undefined') {\n      currentScrollPosition = target.pageYOffset;\n    } else if (target.parentWindow && target.parentWindow.pageYOffset) {\n      currentScrollPosition = target.parentWindow.pageYOffset;\n    }\n\n    let /** @type {?} */ result: string;\n    let /** @type {?} */ value: number;\n\n    value = currentScrollPosition * this.options.ratio + this.options.initValue;\n\n    if (this.options.max !== undefined && currentScrollPosition >= this.options.max) {\n      currentScrollPosition = this.options.max;\n    } else if (this.options.min !== undefined && currentScrollPosition <= this.options.min) {\n      currentScrollPosition = this.options.min;\n    }\n\n    // added after realizing original setup wasn't compatible in Firefox debugger;\n    if (this.options.cssKey === 'backgroundPosition') {\n      if (this.options.axis === 'X') {\n        result = value + this.options.unit + ' 0';\n      } else {\n        result = '0 ' + value + this.options.unit;\n      }\n    } else if (this.isSpecialVal) {\n      result = this.cssValue + '(' + value + this.options.unit + ')';\n    } else {\n      result = value + this.options.unit;\n    }\n\n    this.renderer.setStyle(this.el, this.options.cssKey, result);\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    this.scrollStream$.unsubscribe();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n{ type: Directive, args: [{\n  selector: '[scrollSpyParallax]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Renderer2, },\n{type: ElementRef, },\n{type: ScrollSpyService, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'options': [{ type: Input, args: ['scrollSpyParallax', ] },],\n'scrollSpyParallaxDisabled': [{ type: Input },],\n};\n}\n\nfunction ScrollSpyParallaxDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyParallaxDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyParallaxDirective.ctorParameters;\n/** @type {?} */\nScrollSpyParallaxDirective.propDecorators;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.options;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.scrollSpyParallaxDisabled;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.cssValue;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.isSpecialVal;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.defaultOptions;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.scrollStream$;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.el;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.renderer;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.elRef;\n/** @type {?} */\nScrollSpyParallaxDirective.prototype.scrollSpy;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\n\nexport {ScrollSpyParallaxOptions,ScrollSpyParallaxDirective} from './parallax.directive';\n\nimport { ScrollSpyParallaxDirective } from './parallax.directive';\nexport class  ScrollSpyParallaxModule {static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [ ScrollSpyParallaxDirective ],\n  exports: [ ScrollSpyParallaxDirective ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollSpyParallaxModule_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollSpyParallaxModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollSpyParallaxModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","isFunction","x","hostReportError","err","setTimeout","isObject","tryCatcher","tryCatchTarget","apply","arguments","e","errorObject","tryCatch","fn","flattenUnsubscriptionErrors","errors","reduce","errs","concat","UnsubscriptionError","isTrustedSubscriber","obj","Subscriber","rxSubscriberSymbol","toSubscriber","nextOrObserver","error","complete","emptyObserver","pipeFromArray","fns","length","input","prev","noop","getPromiseCtor","promiseCtor","config","Promise","Error","empty$1","scheduler","emptyScheduled","EMPTY","Observable","subscriber","schedule","isScheduler","value","fromArray","sub","Subscription","i","add","next","closed","subscribeToArray","scalar","result","_isScalar","of","args","_i","pop","undefined","empty","throwError","dispatch","_a","throttleTime","duration","async","defaultThrottleConfig","source","lift","ThrottleTimeOperator","leading","trailing","ScrollSpyService","changes$","EventEmitter","observables","getObservable","key","setObservable","observable","assign","index","change","deleteObservable","decorators","type","Injectable","ctorParameters","setPrototypeOf","__proto__","Array","p","hasOwnProperty","_enable_super_gross_mode_that_will_cause_bad_things","useDeprecatedSynchronousErrorHandling","stack","_super","_this","call","map","toString","join","name","tslib_1.__extends","unsubscribe","_parent","_parents","_subscriptions","_unsubscribe","hasErrors","len","remove","trial","isArray","push","teardown","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","rxSubscriber","Symbol","for","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","trustedSubscriber","SafeSubscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","subscribe","_subscribe","operator","sink","_trySubscribe","forEach","resolve","reject","Symbol_observable","pipe","operations","toPromise","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","AnonymousSubject","copy","slice","thrownError","asObservable","AsyncAction","work","state","delay","id","recycleAsyncId","pending","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","actions","Action","QueueAction","Scheduler","SchedulerAction","now","AsyncScheduler","delegate","active","scheduled","action","shift","queue","QueueScheduler","array","Notification","kind","hasValue","observe","observer","do","accept","toObservable","createNext","undefinedValueNotification","createError","createComplete","completeNotification","ObserveOnSubscriber","arg","notification","scheduleMessage","ObserveOnMessage","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_events","_infiniteTimeWindow","_bufferSize","_windowTime","nextTimeWindow","nextInfiniteTimeWindow","ReplayEvent","_getNow","_trimBufferThenGetEvents","eventsCount","spliceCount","time","Math","max","ScrollSpyDirective","scrollSpy","scrollStream$","ngOnInit","console","warn","onScroll","$event","Directive","selector","host","(window:scroll)","ScrollSpyElementDirective","scrollSpyId","ngOnDestroy","(scroll)","propDecorators","Input","ScrollSpyIndexService","indexes","getIndex","setIndex","emit","deleteIndex","ScrollSpyModule","forRoot","ngModule","providers","NgModule","declarations","exports","ScrollSpyAffixDirective","ref","elRef","affix","affixTop","affixBottom","defaultOptions","topMargin","bottomMargin","el","nativeElement","ngAfterViewInit","_this_1","options","parentEl","parentElement","elementTop","scrollTop","elementBottom","getBoundingClientRect","height","target","scrollingElement","update","scrollY","pageYOffset","parentWindow","currentTop","markForCheck","[class.affix]","[class.affix-top]","[class.affix-bottom]","ChangeDetectorRef","ElementRef","ScrollSpyAffixModule","ScrollSpyIndexDirective","scrollSpyIndex","getElementsByClassName","ScrollSpyIndexRenderComponent","items","itemsHash","itemsToHighlight","spyId","scrollSpyIndexRenderOptions","changeStream$","currentScrollPosition","calculateHighlight","lastItem","data","parentStack","item","link","text","textContent","innerText","parents","children","level","tagName","n","classList","stacksize","j","temp","t","filter","highlightItem","offsetTop","highlight","goTo","anchor","document","querySelector","scrollIntoView","Component","template","changeDetection","ChangeDetectionStrategy","OnPush","ScrollSpyIndexModule","imports","CommonModule","RouterModule","ThrottleTimeSubscriber","_hasTrailingValue","_trailingValue","throttled","dispatchNext","clearThrottle","ScrollSpyInfiniteDirective","scrollSpyInfiniteEvent","distanceRatio","scrollSpyInfiniteDisabled","evaluateScroll","scrollHeight","documentElement","offsetHeight","clientHeight","Output","ScrollSpyInfiniteModule","ScrollSpyParallaxDirective","renderer","isSpecialVal","horizontal","cssKey","property","ratio","initValue","unit","axis","scrollSpyParallaxDisabled","match","split","toUpperCase","cssValArray","cssValue","min","setStyle","Renderer2","ScrollSpyParallaxModule"],"mappings":"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"}
